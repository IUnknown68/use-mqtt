{"version":3,"file":"use-mqtt.js","sources":["../src/types.ts","../src/Subscription.ts","../src/ReactiveMqtt.ts","../src/useMqtt.ts"],"sourcesContent":["import type {\n  Ref,\n} from 'vue';\n\nimport type {\n  MqttClient,\n  Packet,\n  IClientOptions,\n  IClientSubscribeOptions,\n  IClientPublishOptions,\n  ISubscriptionGrant,\n} from 'mqtt';\n\n/**\n * Interface exposed by useMqtt().\n */\nexport interface IMqttApi {\n  client: MqttClientRef,\n  error: ErrorRef,\n  state: ConnectionStateRef,\n\n  connected: Ref<boolean>,\n  busy: Ref<boolean>,\n\n  create: (url: string, options: Partial<IMqttCreateParams> | undefined) => void,\n  open: () => void,\n  close: () => void,\n\n  publish: (\n    topic: string,\n    message: string,\n    options: IClientPublishOptions | undefined,\n  ) => Promise<Packet | undefined>,\n\n  subscribe: (\n    topic: string,\n    options: Partial<ISubscriptionCreateParams> | undefined\n  ) => ISubscriptionApi,\n}\n\n//------------------------------------------------------------------------------\nexport interface IMqttCreateParams {\n  mqtt: IClientOptions,\n  mapValue: MapValueFn,\n}\n\n/**\n * Interface exposed by useSubscription().\n */\nexport interface ISubscriptionApi {\n  value: Ref<unknown>,\n  error: ErrorRef,\n  subscribe: () => void,\n  unsubscribe: () => void,\n}\n\n//------------------------------------------------------------------------------\nexport interface ISubscriptionCreateParams {\n  client: string,\n  mapValue: (message: unknown, topic: string) => unknown,\n  default: unknown,\n}\n\n/**\n * State of the underlying mqtt-connection.\n */\nexport enum ConnectionState {\n  Closed = 0,\n  Connected = 1,\n  // states > Connected indicate busy states:\n  Reconnecting = 2,\n  Disconnecting = 3,\n}\n\n//------------------------------------------------------------------------------\nexport interface ISubscription {\n  ref: Ref<unknown>,\n  topic: string,\n  error: ErrorRef,\n  update: (message: unknown, topic: string, mapGlobal: MapValueFn) => void,\n  subscribe: () => void,\n  unsubscribe: (force?: boolean) => void,\n}\n\n//------------------------------------------------------------------------------\nexport interface ISubscriptionManager {\n  addSubscription: (topic: string, subscription: ISubscription) => Promise<void>,\n  removeSubscription: (topic: string) => Promise<void>,\n}\n\n//------------------------------------------------------------------------------\nexport type MqttClientRef = Ref<MqttClient | null>;\nexport type ErrorRef = Ref<Error | null>;\nexport type ConnectionStateRef = Ref<ConnectionState>;\n\n//------------------------------------------------------------------------------\nexport type MapValueFn = (message: unknown, topic: string) => unknown;\n","import {\n  Ref,\n  ref,\n} from 'vue';\nimport { reactify } from '@vueuse/core';\n\nimport {\n  ISubscriptionCreateParams,\n  MapValueFn,\n  ISubscription,\n  ISubscriptionManager,\n  ErrorRef,\n} from './types';\n\n//------------------------------------------------------------------------------\nclass Subscription implements ISubscription {\n  topic: string;\n  refCount: number;\n  ref: Ref<unknown>;\n  error: ErrorRef;\n\n  constructor(mqtt: ISubscriptionManager, topic: string, options: Partial<ISubscriptionCreateParams> = {}) {\n    this.topic = topic;\n    this.refCount = 0;\n    this.ref = ref(options.default);\n    this.error = ref(null);\n    this.update = this.update.bind(this);\n    this.subscribe = this.subscribe.bind(this);\n\n    this.unsubscribe = (force = false) => {\n      --this.refCount;\n      if (force || (this.refCount < 1)) {\n        this.error.value = null;\n        mqtt.removeSubscription(this.topic).catch((err) => {\n          this.error.value = err as Error;\n        });\n      }\n    };\n\n    if (typeof options.mapValue === 'function') {\n      this.mapValue = options.mapValue;\n    } else {\n      this.mapValue = this.mapValue.bind(this);\n    }\n\n    this.error.value = null;\n    mqtt.addSubscription(this.topic, this).catch((err) => {\n      this.error.value = err as Error;\n    });\n  }\n\n  mapValue(message: unknown, topic: string) {\n    return message;\n  }\n\n  update(message: unknown, topic: string, globalMapValue: MapValueFn) {\n    this.ref.value = this.mapValue(globalMapValue(message, topic), topic);\n  }\n\n  subscribe() {\n    ++this.refCount;\n  }\n\n  unsubscribe(force = false) {\n    // Will be bound with mqtt\n  }\n}\n\nexport default Subscription;\n","import {\n  Ref,\n  ref,\n  shallowRef,\n  shallowReactive,\n  shallowReadonly,\n  watch,\n  unref,\n  onMounted,\n  onBeforeUnmount,\n  getCurrentInstance,\n} from 'vue';\nimport { reactify } from '@vueuse/core';\n\nimport mqttLib, {\n  MqttClient,\n  Packet,\n  IClientOptions,\n  IClientSubscribeOptions,\n  IClientPublishOptions,\n  ISubscriptionGrant,\n} from 'mqtt';\n\nimport {\n  ConnectionState,\n  ISubscription,\n  MqttClientRef,\n  ConnectionStateRef,\n  IMqttApi,\n  IMqttCreateParams,\n  ISubscriptionCreateParams,\n  ISubscriptionApi,\n  ISubscriptionManager,\n} from './types';\n\nimport Subscription from './Subscription';\n\n//------------------------------------------------------------------------------\nconst isConnected = reactify((state: ConnectionState) =>\n  (state === ConnectionState.Connected));\n\n//------------------------------------------------------------------------------\nconst isBusy = reactify((state: ConnectionState) =>\n  (state > ConnectionState.Connected));\n\n//------------------------------------------------------------------------------\nconst getSubscription = reactify(\n  (mqtt: ReactiveMqtt, topic: string, options: Partial<ISubscriptionCreateParams>) =>\n    mqtt.subscriptions.get(topic) || new Subscription(mqtt, topic, options)\n);\n\n//------------------------------------------------------------------------------\nconst getSubscriptionValue = reactify((subscription: ISubscription) =>\n  (subscription.ref.value));\n\n//------------------------------------------------------------------------------\nconst getSubscriptionError = reactify((subscription: ISubscription) =>\n  (subscription.error.value));\n\n//------------------------------------------------------------------------------\nclass ReactiveMqtt implements ISubscriptionManager {\n  id: string;\n  subscriptions: Map<string, ISubscription>;\n  client: MqttClientRef;\n  state: ConnectionStateRef;\n  hook: IMqttApi;\n\n  constructor(id: string) {\n    this.id = id;\n    this.subscriptions = new Map();\n\n    this.client = shallowRef(null);\n    this.state = ref(ConnectionState.Closed);\n\n    this.create = this.create.bind(this);\n    this.open = this.open.bind(this);\n    this.close = this.close.bind(this);\n\n    this.publish = this.publish.bind(this);\n    this.subscribe = this.subscribe.bind(this);\n\n    this.hook = {\n      // Error is writable!\n      error: ref(null),\n      client: shallowReadonly(this.client),\n      state: shallowReadonly(this.state),\n\n      connected: isConnected(this.state),\n      busy: isBusy(this.state),\n\n      create: this.create,\n      open: this.open,\n      close: this.close,\n\n      publish: this.publish,\n      subscribe: this.subscribe,\n    };\n  }\n\n  //----------------------------------------------------------------------------\n  getHook(): IMqttApi {\n    return {\n      ...this.hook,\n    };\n  }\n\n  //----------------------------------------------------------------------------\n  create(url: string, options: Partial<IMqttCreateParams> = {}) : void {\n    (new Promise((resolve, reject) => {\n      const handleError = (err: Error) => {\n        this.state.value = ConnectionState.Closed;\n        reject(err);\n      }\n\n      try {\n        if (this.client.value) {\n          return;\n        }\n        this.hook.error.value = null;\n\n        const {\n          mapValue = (v) => v,\n        } = options;\n\n        this.client.value = mqttLib.connect(url, {\n          ...(options.mqtt || {}),\n          manualConnect: true,\n        });\n\n        this.client.value.on('connect', () => {\n          this.hook.error.value = null;\n          this.state.value = ConnectionState.Connected;\n          for (const subscription of this.subscriptions.values()) {\n            this.client.value!.subscribeAsync(subscription.topic).catch((err) => {\n              subscription.error.value = err as Error;\n            });\n          }\n          resolve(this.hook);\n        });\n\n        this.client.value.on('reconnect', () => {\n          this.hook.error.value = null;\n          this.state.value = ConnectionState.Reconnecting;\n        });\n\n        this.client.value.on('disconnect', (packet) => {\n          this.state.value = ConnectionState.Disconnecting;\n          const err = new Error('Disconnected');\n          reject(err);\n        });\n\n        this.client.value.on('close', () => {\n          this.state.value = ConnectionState.Closed;\n          reject(new Error('Closed'));\n        });\n\n        this.client.value.on('offline', () => {\n          this.state.value = ConnectionState.Closed;\n          reject(new Error('Offline'));\n        });\n\n        this.client.value.on('message', async (topic, message) => {\n          try {\n            const subscription = this.subscriptions.get(topic);\n            if (subscription) {\n              await subscription.update(message, topic, mapValue);\n            } else {\n              await this.client.value!.unsubscribeAsync(topic);\n            }\n          } catch (err) {\n            // TODO: Don't report in production mode.\n            console.warn(`Unsubscribe failed: ${(err as Error).message}`);\n          }\n        });\n\n        this.client.value.on('error', handleError);\n\n        if (!options.mqtt?.manualConnect) {\n          this.client.value.reconnect();\n        }\n      } catch (err) {\n        handleError(err as Error);\n      }\n    })).catch((err) => {\n      this.hook.error.value = err;\n    });\n  }\n\n  //----------------------------------------------------------------------------\n  open() {\n    if (this.client.value && this.state.value === ConnectionState.Closed) {\n      this.client.value.reconnect();\n    }\n  }\n\n  //----------------------------------------------------------------------------\n  close() {\n    if (this.client.value && this.state.value === ConnectionState.Connected) {\n      this.client.value.end();\n    }\n  }\n\n  //----------------------------------------------------------------------------\n  publish(\n    topic: string,\n    message: string,\n    options: IClientPublishOptions | undefined,\n  ) : Promise<Packet | undefined> {\n    if (this.client.value && this.state.value === ConnectionState.Connected) {\n      return this.client.value.publishAsync(topic, message, options);\n    }\n    return Promise.reject(new Error('Not connected'));\n  }\n\n  //----------------------------------------------------------------------------\n  subscribe(\n    topic: string | Ref<string>,\n    options: Partial<ISubscriptionCreateParams> | undefined  = {}\n  ) : ISubscriptionApi {\n    /*\n    const topic: string = unref(topicMaybeRef);\n    const subscription = (this.subscriptions.get(topic) || new Subscription(this, topic, options));\n\n    if (getCurrentInstance()) {\n      onMounted(subscription.subscribe);\n      onBeforeUnmount(subscription.unsubscribe);\n    } else {\n      // Increment refcount when not in a setup().\n      // Requires an explicit unsubscribe(), but for now that's what I consider\n      // the most desired behavior. A subscription might dangle, but you can be\n      // sure it will stay valid even if you forgot to call subscribe().\n      subscription.subscribe();\n    }\n\n    return subscription.getHook();\n    */\n\n    const subscriptionRecordRef = getSubscription(this, topic, options);\n\n    watch(subscriptionRecordRef, (newValue, oldValue) => {\n      if (oldValue) {\n        oldValue.unsubscribe();\n      }\n      if (newValue) {\n        newValue.subscribe();\n      }\n    });\n\n    if (getCurrentInstance()) {\n      onMounted(subscriptionRecordRef.value.subscribe);\n      onBeforeUnmount(subscriptionRecordRef.value.unsubscribe);\n    } else {\n      // Increment refcount when not in a setup().\n      // Requires an explicit unsubscribe(), but for now that's what I consider\n      // the most desired behavior. A subscription might dangle, but you can be\n      // sure it will stay valid even if you forgot to call subscribe().\n      subscriptionRecordRef.value.subscribe();\n    }\n\n    // These will always refer to subscriptionRecordRef, no matter where\n    // that actually points to. So the hook is fully reactive.\n    return {\n      value: getSubscriptionValue(subscriptionRecordRef),\n      error: getSubscriptionError(subscriptionRecordRef),\n      subscribe: () => subscriptionRecordRef.value.subscribe(),\n      unsubscribe: () => subscriptionRecordRef.value.unsubscribe(),\n    };\n  }\n\n  //----------------------------------------------------------------------------\n  async addSubscription(topic: string, subscription: ISubscription) {\n    this.subscriptions.set(topic, subscription);\n    if (this.hook.connected.value && this.client.value) {\n      await this.client.value.subscribeAsync(topic);\n    }\n  }\n\n  //----------------------------------------------------------------------------\n  async removeSubscription(topic: string) {\n    this.subscriptions.delete(topic);\n    if (this.hook.connected.value && this.client.value) {\n      await this.client.value.unsubscribeAsync(topic);\n    }\n  }\n}\n\nexport default ReactiveMqtt;\n","import {\n  ISubscriptionCreateParams,\n} from './types';\n\nimport ReactiveMqtt from './ReactiveMqtt';\n\nexport const DEFAULT_CLIENT_ID = '';\n\nconst clientInstances = new Map<string, ReactiveMqtt>();\n\n//------------------------------------------------------------------------------\nexport function useMqtt(id = DEFAULT_CLIENT_ID) {\n  return getMqtt(id, true).getHook();\n}\n\n//------------------------------------------------------------------------------\nexport function useSubscription(topic: string, options: Partial<ISubscriptionCreateParams> = {}) {\n  return getMqtt(options.client || DEFAULT_CLIENT_ID, true)\n    .subscribe(topic, options);\n}\n\n//------------------------------------------------------------------------------\nfunction getMqtt(id = DEFAULT_CLIENT_ID, create = false) : ReactiveMqtt {\n  let mqtt = clientInstances.get(id);\n  if (!mqtt && create) {\n    mqtt = new ReactiveMqtt(id);\n    clientInstances.set(id, mqtt);\n  }\n  return mqtt!;\n}\n\nexport const test = DEFAULT_CLIENT_ID;\n"],"names":["ConnectionState","ref","reactify","shallowRef","shallowReadonly","watch","getCurrentInstance","onMounted","onBeforeUnmount"],"mappings":"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"}